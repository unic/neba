---
title: NEBA Documentation
twitterAuthor: nebaframework
description: A comprehensive guide to using the NEBA features
---
<!doctype html>
<html lang="en-US">
{% include head.ext %}

<body class="documentation">

{% include navigation.ext %}

<main>
    <section>
        <header>
            <h1>Documentation</h1>
        </header>
        <nav title="Documentation chapters" class="up-to-three-columns">
            <section>
                <header>
                    <h2>Getting started</h2>
                </header>
                <ul>
                    <li><a href="#what_is_neba">What is NEBA?</a></li>
                    <li><a href="#download_and_integrate">Downloading and integrating NEBA</a></li>
                    <li><a href="#add_neba_packages_header">Add the Neba-Packages header to your bundle(s)</a></li>
                    <li><a href="#sample_project">The NEBA sample project</a></li>
                </ul>
            </section>
            <section>
                <header>
                    <h2>Working with @ResourceModels</h2>
                </header>
                <ul>
                    <li><a href="#what_is_a_resource_model">What is a resource model?</a></li>
                    <li><a href="#about_resource_models">Resources, resource types and resource models</a></li>
                    <li><a href="#dependency_injection">Dependency injection</a></li>
                    <li><a href="#using_models_in_views">Using models in views</a></li>
                    <li><a href="#mapping_resources_to_models">Mapping properties and resources to models</a></li>
                    <li>
                        <a href="#resource_model_annotations">Annotations for resource to model mapping</a>
                        <ul>
                            <li><a href="#the_reference_annotation">@Reference</a></li>
                            <li><a href="#the_unmapped_annotation">@Unmapped</a></li>
                            <li><a href="#the_children_annotation">@Children</a></li>
                            <li><a href="#the_path_annotation">@Path</a></li>
                            <li><a href="#the_this_annotation">@This</a></li>
                        </ul>
                    </li>
                    <li><a href="#lazy_loading">Lazy loading</a></li>
                    <li><a href="#json_views">Rendering NEBA models as JSON</a></li>
                    <li><a href="#lifecycle_annotations">Performing additional initializations</a></li>
                    <li><a href="#caching">Application-level caching</a></li>
                </ul>
            </section>
            <section>
                <header>
                    <h2>Using Spring with Sling</h2>
                </header>
                <ul>
                    <li><a href="#spring">Using the Spring Framework with NEBA</a></li>
                    <li><a href="#spring_beans_as_resource_models">Spring Beans as resource models</a></li>
                    <li><a href="#spring_mvc">Using Spring MVC in Sling</a></li>
                    <li><a href="#mvc_sling_views">Using sling Scripts as controller views</a></li>
                    <li><a href="#mvc_resourceparam_annotation">Resolving resource parameters with the @ResourceParam annotation</a></li>
                    <li><a href="#request_scoped_beans">Support for request-scoped beans</a></li>
                </ul>
            </section>
            <section>
                <header>
                    <h2>Extending NEBA</h2>
                </header>
                <ul>
                    <li><a href="#custom_annotations">Implementing custom annotations</a></li>
                    <li><a href="#lifecycle_callbacks">Lifecycle callbacks</a></li>
                    <li><a href="#custom_models">Providing custom resource models</a></li>
                </ul>
            </section>
            <section>
                <header>
                    <h2>Tooling for developers and administrators</h2>
                </header>
                <ul>
                    <li><a href="#tooling_modelregistry">The model registry</a></li>
                    <li><a href="#tooling_modelstatistics">The model statistics</a></li>
                    <li><a href="#tooling_logviewer">The log viewer</a></li>
                </ul>
            </section>
            <section>
                <header>
                    <h2>API documentation</h2>
                </header>
                <ul>
                    <li><a href="apidocs/neba-api/index.html">NEBA API javadoc <span class="pennant"><span class="fa fa-external-link"></span></span></a></li>
                    <li><a href="apidocs/neba-core/index.html">NEBA core javadoc <span class="pennant"><span class="fa fa-external-link"></span></span></a></li>
                    <li><a href="apidocs/neba-spring/index.html">NEBA spring javadoc <span class="pennant"><span class="fa fa-external-link"></span></span></a></li>
                </ul>
            </section>
            <section>
                <header>
                    <h2>The Architecture of NEBA</h2>
                </header>
                <ul>
                    <li><a href="#architecture_bundles">Bundles</a></li>
                    <li><a href="#architecture_resource_model_registration">Resource model registration</a></li>
                </ul>
            </section>
            <section>
                <header>
                    <h2>Previous Versions</h2>
                </header>
                <ul>
                    <li>
                        <a href="/assets/documents/NEBA-4.3.0-Documentation.pdf" title="NEBA 4.3.x">NEBA 4.3.x Documentation (PDF)</a>
                    </li>
                </ul>
            </section>
            <section>
                <header>
                    <h2>Upgrading</h2>
                </header>
                <ul>
                    <li>
                        <a href="#upgrading" title="Upgrading from one NEBA version to another">Upgrading from previous NEBA versions</a>
                    </li>
                </ul>
            </section>
        </nav>
    </section>
    <section>
        <header>
            <h2 id="what_is_neba">What is NEBA?</h2>
        </header>
            <p>
            NEBA is a lightweight, high-performance and open source Content-to-Object mapping extension for Apache Sling and Adobe AEM&trade;.
            With NEBA's minimal set of well-documented annotations, engineers can easily use repository content of arbitrary complexity
            to build building well maintainable, high performance solutions in AEM&trade; and Apache Sling.
            <br />
            In addition, NEBA provides an optional integration of <a href="#spring">Spring and Spring MVC</a> - the de-facto standard
            for java enterprise applications - and its enormous ecosystem of read--to-use solutions.
            </p>
            <p>
                <a href="#what_is_a_resource_model">NEBA models are Java POJO's with a simple annotation</a>, allowing <em>type-safe</em> representation of repository data. Performance-critical features, such as <a href="#lazy_loading">lazy loading</a>
                and <a href="#tooling_modelstatistics">tooling to monitor model behavior</a> are provided out-of-the-box.
            </p>
            <p>
                NEBA strives for simplicity and furthers readable and changeable code. It does so by adhering to the principals of Separation of Concerns and providing sensible defaults.
                For instance, NEBA does not mix <a href="#dependency_injection">Dependency Injection</a> with content mapping or handling HTTP requests and maps content to fields by default - just like mature
                persistence standards like the Java Persistence API (JPA).
            </p>
        <h3 id="difference_from_sling_models">How is NEBA different from Sling Models?</h3>
        <p>
            NEBA and Sling models are are no contradiction and can be used alongside without any issue. Sling Models and NEBA models can even be injected into one another.
        </p>
        The key differences are:
        <ul>
            <li>NEBA always associates its models with sling resource types or JCR node types to facilitate type safety.</li>
            <li>NEBA has been developed for high-performance and features request-scoped caching and lazy-loading out of the box.</li>
            <li>NEBA ships with comprehensive tooling to support developers and administrators.</li>
            <li>NEBA provides extensible semantic annotations for almost all possible use cases to maximise convenience and minimize code.</li>
            <li>NEBA ships an optional integration with Spring and Spring MVC, thus allowing to use the de facto standard for Java Enterprise Applications to be used with Sling and AEM&trade;.</li>
        </ul>
    </section>
    <section>
        <header>
            <h2 id="getting_started">Getting started</h2>
        </header>

        <p>Get started with NEBA with two simple steps:</p>

        <h3 id="download_and_integrate">Step 1: Download and install NEBA</h3>
        <p>
            <a href="download.html">Install the delivery package and add a dependency to the NEBA API to your project.</a>
        </p>

        <h3 id="add_neba_packages_header">Step 2: Add the Neba-Packages header to your bundle(s)</h3>
        <p>Add a comma-separated list of packages containing your NEBA models to your bundle, e.g. using maven:</p>
        <figure class="listing" id="listing:addnebapackagesheader">
{% highlight xml %}<plugin>
    <groupId>org.apache.felix</groupId>
    <artifactId>maven-bundle-plugin</artifactId>
    <configuration>
        <instructions>
            <Neba-Packages>
                my.project.models
            </Neba-Packages>
        </instructions>
    </configuration>
</plugin>{% endhighlight %}
        <figcaption>Declaring model packages for OSGi bundles</figcaption></figure>

        <p>That's it - you may now proceed to <a href="#working_with_resourcemodels">Write resource models</a>. You can use the <a href="#sample_project">sample project as a starting point</a></p>

        <h3 id="sample_project">The NEBA sample project</h3>
        <p>The NEBA sample project demonstrates both the Neba-Packages based core functionality and using the Neba Spring integration.</p>
        <a href="https://github.com/unic/neba-sample-project">View the NEBA sample project on Github</a>
    </section>


    <section><header><h2 id="working_with_resourcemodels">Working with @ResourceModels</h2></header>
        <h3 id="what_is_a_resource_model">What is a resource model?</h3>

        <p>
            A Resource model is a type safe representation of a <a href="https://sling.apache.org/documentation/the-sling-engine/resources.html">Sling resource</a>, written as a Java class. The data of a resource can be mapped to the resource model, similar to an ORM mapping the data of a relational DB to an entity class.
            In addition, resource models can be injected with collaborators, e.g. OSGi services.
            Resource model instances are obtained by <a href="https://sling.apache.org/documentation/the-sling-engine/adapters.html#adaptable">adapting</a> a resource to the type or super type of the resource model.
            A resource model and the Sling resource types it represents are defined using the <a href="apidocs/neba-api/io/neba/api/annotations/ResourceModel.html">@ResourceModel</a> annotation.
        </p>
        <p>
            Resource models are useful for explicitly modelling complex resource relationship semantics and functionality belonging to specific resource
            types and the data of the corresponding resources.
        </p>
        <p>
            Resource models are not useful for simply exposing the properties of the current resource in a view - here, using Sling's generic <code>${properties}</code> or
            <code>${resource}</code> representation is recommended.
        </p>

        <h3 id="about_resource_models">Resources, resource types and resource models</h3>

    <section class="info">
        <h4>Background: How NEBA uses resource types in Sling</h4>
        <p>The <a href="http://sling.apache.org/site/index.html">Sling Web Framework</a> is a REST architecture implementation.
            Consequently, it treats each thing it works with (every piece of content, every script, servlet) as a <a href="http://sling.apache.org/site/resources.html">Resource</a>.
            Resources are typed using the property <em>sling:resourceType</em>. Resource types - very much like types in many other languages - also support inheritance
            by means of a <em>sling:resourceSuperType</em> attribute.</p>

        <p>Resource types are used by Sling to determine the view(s) that shall be used to render the resource. It does so by adding
            a prefix such as /apps or /libs to the resource type and checking whether it finds views for the
            resource in the corresponding directory.</p>

        <p>Furthermore, any content stored in the JCR is represented by a javax.jcr.Node. <a href="http://jackrabbit.apache.org/jcr/node-types.html">Nodes are strongly typed</a>.
            They always possess a <em>primaryType</em> as well as an arbitrary number of<em>mixin types</em>.
            Both the primary type and the mixin types can have <em>super types</em>.</p>

        <p>In order to provide a JAVA model for a resource, they are thus associated
            with either the resource's sling:resourceType or the resource's Node type(s). NEBA represents this association using the <a href="apidocs/neba-api/io/neba/api/annotations/ResourceModel.html">@ResourceModel</a>
            annotation.</p>
    </section>

    <p>Let's assume we need a simple JAVA model for a sling component called &quot;carousel&quot;.
        The carousel has the sling:resourceType &quot;foundation/components/carousel&quot;. The component has the following properties:</p>

    <figure class="listing" id="listing:sample-content">
{% highlight json%}{
  "jcr:primaryType": "nt:unstructured",
  "playSpeed": "6000",
  "jcr:lastModifiedBy": "admin",
  "pages": [
    "/content/geometrixx/en/events/techsummit",
    "/content/geometrixx/en/events/userconf"
  ],
  "jcr:lastModified": "Tue Oct 05 2010 14:14:27 GMT+0200",
  "transTime": "1000",
  "sling:resourceType": "foundation/components/carousel",
  "listFrom": "static"
}{% endhighlight %}
        <figcaption>A typical JSON view of JCR repository content</figcaption></figure>

    <p>Create the following class in your bundle package (i.e. within or below the &quot;my.project.models&quot;
        package)</p>

    <figure class="listing" id="listing:resource-model-annotation">
        {% highlight java %}@ResourceModel("foundation/components/carousel")
public class Carousel {
}{% endhighlight %}<figcaption>Application of the @ResourceModel annotation</figcaption></figure>

    <p>The resource type given in the @ResourceModel annotation does not have to be the exact
        resource type of the resource. One may also specify any resource super type of the resource, primary
        node type or mixin type. for example, the resource super type of the carousel could be &quot;foundation/components/list&quot;.
        Using this resource type in a @ResourceModel would work, too. This way, one can provide general models for super types,
        and more specific models for derived types, e.g. a generic model for pages and  a more specific model
        for specific page types.</p>

    <section class="info">
        <h4>Background: The @ResourceModel annotation</h4>
        <p>
            Classes annotated with <a href="/apidocs/neba-api/io/neba/api/annotations/ResourceModel.html">@ResourceModel</a> are automatically detected by NEBA if their package is listed in the "Neba-Packages" bundle header.
            For each detected model, NEBA registers the defined resource types and node types supported by the model and
            automatically registers an <a href="https://sling.apache.org/documentation/the-sling-engine/adapters.html#adapterfactory">Adapter Factory</a> supporting the adaptation of resources to the model.
        </p>
    </section>

    <p>Once a bundle with NEBA models is active, all of its models appear in the <a href="#tooling_modelregistry">NEBA model registry (/system/console/modelregistry)</a> in the sling console.
        If they are not visible in the model registry, the bundle either failed to start or is missing the "Neba-Packages" header.</p>

        <section>
            <header><h3 id="dependency_injection">Dependency injection</h3></header>
        <p>
            NEBA clearly separates dependency injection from content mapping and makes sure these two concepts are not mixed.
            The bottom line is: Dependency injection exclusively uses @Inject (if you are using <a href="#spring">Spring</a>, you can also use all Spring DI features).
            Content mapping is not dependency injection, and is performed automatically on suitable fields of a model, optionally using <a href="#resource_model_annotations">NEBA's dedicated annotations</a>.
            Mapped content is always optional, whereas injected dependencies are mandatory by default, unless explicitly <a href="#optional_dependency_injection">made optional</a>.
        </p>

        <h4 id="the_filter_annotation">Injecting OSGi services</h4>
        <p>
            Unless the model is a Spring bean, NEBA exclusively injects OSGi services. Dependency injection is performed using a constructor, fields or setter methods annotated with <code>@Inject</code>.
            Additionally, the injected services can be filtered using the <a href="/apidocs/neba-api/io/neba/api/annotations/Filter.html">@Filter</a> annotation.
        </p>

        <figure class="listing" id="listing:field-injection">
        {% highlight java %}@ResourceModel("my/resource/type")
public class SomeModelClass {
    @Inject
    @Filter("(zone=eu)")
    private DataSource dataSource;
}{% endhighlight %}<figcaption>Using @Inject and @Filter to inject OSGi services into fields</figcaption></figure>

        The @Filter annotation <em>cannot be used by models managed in a Spring Application Context</em>. Here, <a href="https://www.eclipse.org/gemini/blueprint/documentation/reference/3.0.0.M01/html-single/index.html#service-registry:annotations-vs-xml-declarations">OSGi services can be injected by importing them into the application context using blueprint
            or by using the gemini blueprint @ServiceReference annotation</a>.

        <p>
        NEBA supports constructor injection in the same fashion:
        </p>

        <figure class="listing" id="listing:constructor-injection">
        {% highlight java %}@ResourceModel("my/resource/type")
public class SomeModelClass {
    public SomeModelClass(@Inject @Filter("(zone=eu)") DataSource ds) {
        this.dataSource = ds;
    }
}{% endhighlight %}<figcaption>Using @Inject and @Filter to inject OSGi services into constructors</figcaption></figure>

        <p>
        For resource models that do not stem from a Spring Application Context, NEBA supports either the default constructor or exactly one constructor annotated with @Inject,
        with the @Inject constructor taking precedence.
        </p>

        <h4 id="optional_dependency_injection">Optional dependencies</h4>
        <p>
            By default, service dependencies via @Inject are mandatory. Obtaining a resource model will thus fail if the respective OSGi service is unavailable.
            Optional Service dependencies can be declared using <code>java.util.Optional</code>. This is supported for both field and constructor injection:
        </p>

        <figure class="listing" id="listing:optional-injection">
        {% highlight java %}@ResourceModel("my/resource/type")
public class SomeModelClass {
    @Inject
    private Optional<OtherService> otherService;

    public SomeModelClass(@Inject @Filter("(zone=eu)") Optional<DataSource> ds) {
        this.dataSource = ds;
    }
}{% endhighlight %}<figcaption>Using java.util.Optional for optional service dependencies</figcaption></figure>

        <h4 id="multiple_service_dependencies">Injecting multiple instances of the same service</h4>
        <p>NEBA allows injecting multiple instances of the same service, with an optional @Filter annotation (the @Filter annotation is optional since NEBA 5.0.1). </p>

        <figure class="listing" id="listing:multiple-injection">
        {% highlight java %}@ResourceModel("my/resource/type")
public class SomeModelClass {
    @Inject
    @Filter("(some=filter)")
    private List<OtherService> otherServices;

    public SomeModelClass(@Inject List<DataSource> dataSources) {
        this.dataSources = dataSources;
    }
}{% endhighlight %}<figcaption>Injecting multiple instances of the same OSGi service</figcaption></figure>

        </section>

    <h3 id="using_models_in_views">Using models in views</h3>

    <p>Resource models can be used in either HTL (Sightly) or JSP views by adapting the resource to the desired model, like so:</p>

    <figure class="listing" id="listing:adapt-to-neba-model-in-htl">
        {% highlight html %}<sly data-sly-use.m="my.package.MyModel"> ...</sly>{% endhighlight %}<figcaption>Adapting to a NEBA model in HTL (Sightly)</figcaption></figure>

    <figure class="listing" id="listing:adapt-to-neba-model-in-jsp">
        {% highlight java %}<sling:adaptTo adaptable="${resource}" adaptTo="my.package.MyModel" var="m" />{% endhighlight %}<figcaption>Adapting to a NEBA model in JSP</figcaption></figure>

    <h3 id="mapping_resources_to_models">Mapping properties and resources to models</h3>

    <p>
        <span id="the_unmapped_annotation">NEBA automatically maps the properties of a Resource to fields named like the properties, unless the field is
            annotated with <a href="apidocs/neba-api/io/neba/api/annotations/Unmapped.html">@Unmapped</a>, <code>@Inject</code>, is static or final.</span> Additional semantics, such as mapping referenced resource, children or specific paths are
        supported by a an <a href="#custom_annotations">extensible</a> set of <a href="#resource_model_annotations">annotations</a>.
        Following, we will map the properties of the following resource:
    </p>
    <figure class="listing" id="listing:sample-content-repeat">
            {% highlight json%}{
  "jcr:primaryType": "nt:unstructured",
  "playSpeed": "6000",
  "jcr:lastModifiedBy": "admin",
  "pages": [
    "/content/geometrixx/en/events/techsummit",
    "/content/geometrixx/en/events/userconf"
  ],
  "jcr:lastModified": "Tue Oct 05 2010 14:14:27 GMT+0200",
  "transTime": "1000",
  "sling:resourceType": "foundation/components/carousel",
  "listFrom": "static"
}{% endhighlight %}<figcaption>A typical JSON view of JCR repository content</figcaption></figure>

    <p>Let's select &quot;pages&quot;, &quot;playSpeed&quot;, &quot;transTime&quot; and add them to the model:</p>

    <figure class="listing" id="listing:neba-resourcemodel-with-simple-fields">
        {% highlight java %}@ResourceModel("foundation/components/carousel")
public class Carousel {
    private String playSpeed;
    private String transTime;
    private List<String> pages;

    public String getPlaySpeed() {
        return playSpeed;
    }
    public String getTransTime() {
        return transTime;
    }
    public List<Resource> getPages() {
        return pages;
    }
}{% endhighlight %}<figcaption>A simple @ResourceModel with mapped fields</figcaption></figure>

        <p>The properties of the model may then be rendered like so:</p>

    <figure class="listing">
    {% highlight java %}Play speed: ${m.playSpeed}
Trans time: ${m.transTime}
Pages: ${m.pages}{% endhighlight %}
    </figure>

    <p>This will create the following output:</p>

    <figure class="listing">
    {% highlight java %}Play speed: 6000
Trans time: 1000
Pages: ["/content/geometrixx/en/events/techsummit", ...]{% endhighlight %}
    </figure>

    <h3 id="resource_model_annotations">Annotations for resource to model mapping</h3>

    <p>
        By default, NEBA will map all fields of a model from the properties or child resources of the adapted resource, unless the fields are static, final,
        annotated with <a href="/apidocs/neba-api/io/neba/api/annotations/Unmapped.html">@Unmapped</a>, @Inject or @Autowired. The following annotations are thus only needed
        if a simple property-to-field mapping is not enough.
    </p>

    <h4 id="the_reference_annotation">Resolving references with the @Reference annotation</h4>

        <p>In the <a href="#listing:sample-content-repeat">above example</a>, &quot;pages&quot;
        is an array of strings and not the actual resources the "pages" property is referring to. If you want to resolve and / or adapt the referenced resources,
        NEBA provides the <a href="apidocs/neba-api/io/neba/api/annotations/Reference.html">@Reference</a> annotation to declare that a
        field contains one ore more <em>references</em> to other Resources:</p>

    <figure class="listing" id="listing:neba-reference-annotation">
        {% highlight java %}@Reference
private List<Resource> pages;{% endhighlight %}<figcaption>Using the @Reference annotation</figcaption></figure>

    <p>When NEBA detects a @Reference annotation, it assumes that the <em>value</em> of the corresponding property is one
        or more resource paths. It obtains the corresponding resources and provides them as a Collection
        (or a single resource, if the annotated field is not a collection type). However, you are not limited
        to using &quot;Resource&quot; for your reference. The following also works, provided there is a &quot;Page&quot;
        model the referenced resources can be adapted to:</p>

    <figure class="listing" id="listing:neba-reference-annotation-with-adaptto">
    {% highlight java %}@Reference
private List<Page> pages;{% endhighlight %}<figcaption>Using the @Reference annotation with resource adaptation</figcaption></figure>

    <p>Here, NEBA loads the resource referenced in the &quot;pages&quot; property, adapts each resource to &quot;Page&quot;
        and returns a collection containing the resulting non-null Page instances.</p>

    One can also alter the path of the reference prior to resolution by appending a relative path segment to the reference(s), like so:

    <figure class="listing" id="listing:neba-reference-annotation-with-append">
    {% highlight java %}@Reference(append = "/jcr:content")
@Path("pages")
private List<PageContent> pageContents;{% endhighlight %}
    <figcaption>Appending paths to the resources resolved via the @Reference annotation</figcaption></figure>

    <p>
        Here, instead of resolving and adapting the paths in the property "pages" directly, "/jcr:content" is appended to all of the paths prior to resolution. Note also
        the use of the <a href="#the_path_annotation">@Path annotation</a> to define the property name.
    </p>

    <h4 id="the_children_annotation">Resolving children with the @Children annotation</h4>

    <p>While the resource hierarchy is conveniently
        navigable using the generic Resource model (i.e. using getChildren()), one often has to subsequently adapt the children. Consequently,
        the children are adapted in a loop, including a null check for each adaptation result. Here, NEBA offers
        another powerful annotation: <a href="apidocs/neba-api/io/neba/api/annotations/Children.html">@Children</a>. This annotation can be used on a Collection, Set or List-typed field
        (similar to the <a href="apidocs/neba-api/io/neba/api/annotations/Reference.html">@Reference</a>-annotation). Then, NEBA injects the children of either the current resource (if no other
        annotation is present), or of the resource defined by the <a href="apidocs/neba-api/io/neba/api/annotations/Reference.html">@Reference</a> or <a href="apidocs/neba-api/io/neba/api/annotations/Path.html">@Path</a> of the field:</p>

    <figure class="listing" id="listing:neba-children-annotation">
    {% highlight java %}@Children
private List<Resource> children;{% endhighlight %}
    <figcaption>Using the @Children annotation to retrieve the children of the current resource</figcaption></figure>

    <p>Of course, NEBA will also automatically adapt the children to the generic type of the list - for instance,
        you could write:</p>

    <figure class="listing" id="listing:neba-children-annotation-with-adaptation">
    {% highlight java %}@Children
private List<Page> childPages;{% endhighlight %}
    <figcaption>Using the @Children annotation with adaptation</figcaption></figure>

        <p><a href="apidocs/neba-api/io/neba/api/annotations/Children.html">@Children</a> can be combined with both <a href="apidocs/neba-api/io/neba/api/annotations/Reference.html">@Reference</a> and <a href="apidocs/neba-api/io/neba/api/annotations/Path.html">@Path</a> to fetch the children of a referenced resource
        or a resource designated by a specific path, i.e. the following works as well:</p>

    <figure class="listing" id="listing:combination-of-children-reference-path">
    {% highlight java %}@Path("/content/site")
@Children
// Contains the children of /content/site
private List<Page> countryPages;

@Reference
@Path("link")
@Children
// Contains the children of resource referenced in the resource property "link"
private List<Page> linkChildren;

@Reference
@Children
// Also contains the children of resource referenced in the resource property "link"
private List<Page> link;{% endhighlight %}
    <figcaption>Combining @Children, @Reference and @Path</figcaption></figure>

    <p>
        Furthermore, one may specify a relative path to be resolved below every child using the property "resolveBelowEveryChild".
        For example, one could obtain all resources named "jcr:content" underneath all children of the current resource, like so:
    </p>

    <figure class="listing" id="listing:neba-children-annotation-with-resolvebeloweverychild">
        {% highlight java %}@Children(resolveBelowEveryChild = "jcr:content")
private List<PageContent> childPageContents;{% endhighlight %}
<figcaption>Altering the paths of the resources resolved by @Children</figcaption></figure>

    <h4 id="the_path_annotation">Using the @Path annotation to specify property names or resource paths</h4>

    <p>Lets assume a property called "jcr:lastModified" shall be mapped to a model.</p>

    <figure class="listing">
    {% highlight java %}private Date lastModified;{% endhighlight %}
    </figure>

    <p>This will not yet work - NEBA maps the properties by <em>name</em>, in this case the name contains
        characters (&quot;jcr:&quot;) unsuitable for a field name. In such cases, use the @Path annotation to specify
        the property from which the field's value shall be obtained:</p>

    <figure class="listing" id="listing:neba-path-annotation">
        {% highlight java %}@Path("jcr:lastModified")
private Date lastModified;{% endhighlight %}<figcaption>Using the @Path annotation</figcaption></figure>

    <p>@Path is not limited to property names, but allows specifying absolute and relative paths:</p>

    <figure class="listing" id="listing:neba-path-annotation-with-absolute-paths">
        {% highlight java %}@Path("/content/geometrixx/en")
private Resource en;

@Path("..")
private Resource parent;{% endhighlight %}<figcaption>Using the @Path annotation with absolute and relative paths</figcaption></figure>

    <p id="path_placeholders">Furthermore, one can use placeholders in the @Path to dynamically provide path elements:</p>

    <figure class="listing" id="listing:path-annotation-with-placeholders">
    {% highlight java %}@Path("/content/geometrixx/${language}")
private Resource homepage;{% endhighlight %}
    <figcaption>Using placeholders in the @Path annotation</figcaption></figure>

    <p>To resolve the ${language} placeholder, provide an OSGi service implementing the
        <a href="/apidocs/neba-api/io/neba/api/spi/PlaceholderVariableResolver.html">PlaceholderVariableResolver interface</a>.
        Such services will be asked to resolve the value for a placeholder key, i.e. &quot;language&quot;
        in the above example. The first service to resolve a nun-null value for the placeholder will win. A hardcoded example:</p>

    <figure class="listing" id="listing:neba-placeholder-variable-resolver">
    {% highlight java %}public class MyVariableResolver implements PlaceholderVariableResolver {
    public String resolve(String variableName) {
        if ("language".equals(variableName)) {
            return "en";
        }
        return null;
    }
}{% endhighlight %}<figcaption>A PlaceholderVariableResolver implementation</figcaption></figure>

    <h4 id="the_this_annotation">The @This annotation</h4>

        <p>Fields annotated with <a href="apidocs/neba-api/io/neba/api/annotations/This.html">@This</a> are injected with the current resource, or anything the resource is adaptable to. This annotation is thus not just useful for
    accessing the underlying Resource but has significant architectural value. Using @This, one may split up a model into multiple aspects and compose them dynamically, like so:</p>

    <figure class="listing" id="listing:neba-this-annotation">
        {% highlight java %}@ResourceModel(...)
public class MyModel {
    @This
    // OtherModel models a different aspect of the same resource.
    private OtherModel resource;
}{% endhighlight %}<figcaption>Using the @This annotation</figcaption></figure>

    <p>One can also use the @This annotation to obtain the Resource that is mapped onto the model:</p>

    <figure class="listing" id="listing:neba-this-annotation-for-resource">
    {% highlight java %}@This
private Resource resource;{% endhighlight %}<figcaption>Using the @This annotation to retrieve the resource that is mapped to the model</figcaption></figure>

    <h3>Models for crosscutting concerns</h3>
        <p>A <a href="apidocs/neba-api/io/neba/api/annotations/ResourceModel.html">@ResourceModel</a> is not restricted to sling:resourceType's - one can also map
        it to the JCR primary node type or any of the mixin types of a Node. For example, let's assume that there is
        a requirement to implement a custom access protection of <em>arbitrary</em> content. In addition, a content manager may <em>configure</em>
        access restriction to <em>any</em> content (e.g. pages or a binary assets). In this case, neither the resource
        types nor the content paths to which the protection applies are known in advance.
        Here, using a mixin node type could help. A mixin can be assigned to any
        node at any time anywhere in the content hierarchy. It can define additional properties that can be set
        on the node, such as a set of properties defining how an access restriction is configured. Let us
        assume a protected content is assigned the mixin &quot;mix:AccessRestricted&quot;. One may then create
        a model for any access restricted content like so:</p>

    <figure class="listing" id="listing:resourcemodel-for-mixin-type">
        {% highlight java %}@ResourceModel("mix:AccessRestricted")
public class AccessRestricted {
 ....
}{% endhighlight %}<figcaption>Defining a @ResourceModel for a mixin type</figcaption></figure>

    <p>Finally, one can adapt to this model (e.g., in a view or filter) to determine whether the
        corresponding resource has restricted access, and what the restrictions are.</p>

    <p>You can either use the
        <a href="https://experienceleague.adobe.com/docs/experience-manager-65/content/implementing/developing/platform/custom-nodetypes.html">existing nodes types in AEM and Sling</a> or
        add your own, e.g. by <a href="http://www.tothenew.com/blog/custom-node-type-in-aem/">creating and deploying CND (JCR node type definition) files</a>. There
        is even an <a href="https://plugins.jetbrains.com/plugin/9221-cnd-language--jahia-framework">IntelliJ IDEA plugin for CND files</a> offering some syntax support.
        You may also want to read up on the <a href="http://jackrabbit.apache.org/jcr/node-types.html">Jackrabbit Oak documentation of JCR node types</a> and the
        <a href="https://docs.adobe.com/docs/en/spec/jcr/2.0/3_Repository_Model.html">JCR repository spec</a>.</p>

    <h3 id="lazy_loading">Lazy loading</h3>

    <p>
        Reading data into an object graph - such as NEBA models - bears the risk of loading
        more data than required for rendering. Especially when there is a significant amount of repository content, being able to load
        models <em>on demand</em> rather then up front is <em>crucial</em> for building high-performance implementations. To achieve this,
        NEBA enables lazy-loading model relationships.
    </p>

    <h4>Lazy loading collections of references</h4>

    <p>
    All collection-typed references are automatically provided as lazy-loading proxies, for example
    <a href="#the_children_annotation">@Children</a> and <a href="#the_reference_annotation">@Reference</a> collections:
    </p>

    <figure class="listing" id="listing:neba-implicit-lazy-loading">
        {% highlight java %}@ResourceModel("...")
public class MyModel {
  @Children
  private List<Page> children; // Provided as a lazy-loading proxy
  @Reference
  private Collection<Page> pages; // Provided as a lazy-loading proxy as well
}{% endhighlight %}<figcaption>Automatic lazy-loading of collection-type instance in NEBA</figcaption></figure>

    <p>
    The contents of these collections are loaded as soon as a collection method - such as get, size, isEmpty, iterator - is called.
    The lazy-loading behavior for collections is thus completely transparent.
    </p>

    <h4 id="the_lazy_interface">Declaring lazy-loading relationships using the Lazy&lt;T&gt; interface</h4>

    <p>
    1:1 relationships are not automatically lazy. In order to make them lazy-loading,
    NEBA provides the <a href="apidocs/neba-api/io/neba/api/resourcemodels/Lazy.html">Lazy</a> interface:
    </p>

    <figure class="listing" id="listing:explicit-lazy-loading-with-lazy">
        {% highlight java %}@ResourceModel("...")
public class MyModel {
  @Reference
  private Lazy<Page> page;
  @Path("/content/path")
  private Lazy<Resource> otherResource;
}{% endhighlight %}<figcaption>Explicit lazy-loading using the Lazy interface</figcaption></figure>

    With Lazy, the relationship is loaded when one of Lazy's methods for model retrieval is invoked, such as "orElse".

    <section class="info">
        <h4>Background: Why 1:1 relationships cannot be lazy by default</h4>
        <p>
            Let us assume there is a resource model that references a resource "r":
        </p>

        <figure class="listing">
        {% highlight java %}@ResourceModel("...")
public class MyModel {
  @Reference
  private Resource r;

  public void doSomething() {
      if (r != null) {
         // work with r
      }
  }
}{% endhighlight %}
        </figure>

        <p>
           Of course, any client working with "r" must know whether it exists. However, there is no natural "empty" representation for Resource -
           it is either null or not. Now, if r was provided as a lazy-loading proxy that proxy instance would never be null (since determining whether the resource represented by "r" exists
           would mean having to load it, which defeats the purpose of lazy-loading).
        </p>
        <p>
            A user of "r" would only find out that "r" does not exist when accessing a method of the "r" lazy-loading proxy - and receiving an
            unchecked exception in return, since the proxy cannot dispatch the method call as the loaded "r" is null.
        </p>
        <p>
            Consequently, lazy 1:1 relationships <em>must</em> be explicit to allow clients to determine whether the relationship exists.
            Collections, however, do have a natural representation of emptiness (isEmpty) and are thus automatically provided as lazy-loading proxies by NEBA.
        </p>
    </section>

    <p>
    The Lazy&lt;T&gt; interface provides all features of the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">JAVA 8 "Optional" type</a>. NEBA
    automatically provides an implementation that will load the reference upon request. Of course, you may also use the interface for collection-typed references:
    </p>

    <figure class="listing" id="listing:explicit-lazy-loading-collections">
        {% highlight java %}@ResourceModel("...")
public class MyModel {
  @Children
  private Lazy<Collection<Page>> children;
  @Reference
  private Lazy<Collection<Page>> pages;
}{% endhighlight %}<figcaption>Explicit lazy loading of collection instances</figcaption></figure>

    <p>
        In this case, NEBA will not provide the collection as a lazy-loading proxy, but simply load it when requested via
        the Lazy interface implementation.
    </p>

    <h3 id="json_views">Rendering NEBA models as JSON</h3>
        <p>
    Since 5.1.0, NEBA features an out of the box JSON rendering servlet. This servlet can be configured to respond to certain selectors and resource types and will adapt the request's
        resource to a specified or the most specific NEBA model and render a JSON view.
        To enable the JSON rendering, head to the system console's configuration tab and add a configuration to the <em>NEBA model JSON view servlet</em>.
        </p>
        <p>
            Here, you can configure an arbitrary amount of JSON view renderers. For each configuration, a dedicated servlet instance will be published hence allowing for dedicated
            configurations in a multi-tenant scenario. Each JSON view servlet can be configured wth its own selectors and Jackson features. In addition, The servlet supports
            HTTP Etag generation based on the resource and customized Cache-Control headers.
        </p>
        <p>
            After a JSON view configuration is added, a resource's model can be rendered as JSON using the URL schema
{% highlight java %}</resource/path>.<one of the configured selectors>[.<optional specific model name>].json
// E.g. /content/site/en_US/contact.neba.json
{% endhighlight %}
        </p>
        <p>
            An example for configuring and using NEBA JSON views can be found in the <a href="#sample_project">NEBA sample project</a>.
        </p>


    <h3 id="lifecycle_annotations">Performing additional initializations</h3>

    <p>Sometimes it is necessary to perform additional initializations
        after all collaborators of a @ResourceModel are injected and all resource properties have been mapped to the model.
        Here, using the <a href="apidocs/neba-api/io/neba/api/annotations/AfterMapping.html">@AfterMapping annotation</a> is recommended,
        as it guarantees that model construction, dependency injection and content-to-model mapping have completed regardless of the
        model source, e.g. <a href="#add_neba_packages_header">Neba-Packages</a> or a spring application context).
        When using Spring, @PostConstruct will always be invoked <em>prior to content-to-object mapping</em> due to bean life cycle restrictions by spring.
    </p>

    <figure class="listing" id="listing:aftermapping">
        {% highlight java %}@ResourceModel("my/model/type")
public class MyModel {
   @This
   private Resource resource;
   @AfterMapping
   public void initializeSomething() {
        // resource is initialized at this point.
        this.resource.adaptTo...
   }
}{% endhighlight %}<figcaption>Using the @AfterMapping annotation</figcaption></figure>

<h3 id="caching">Application-level caching</h3>
<p>
NEBA's central and most performance critical feature is the adaptation of resource models. There, resource and model resolution, content-to-model mapping and data type conversion occurs.
This core functionality features a safe and sensible integrated cache, the <em>request-scoped resource model cache.</em>
This cache can be disabled via the Felix console (configuration tab). For further information, consult the Javadoc of the <a href="https://neba.io/apidocs/neba-core/io/neba/core/resourcemodels/caching/RequestScopedResourceModelCache.html">ResourceModelCache</a>.</p>

    </section>


<section>
    <header><h2 id="spring">Using the Spring Framework with NEBA</h2></header>

<section class="info">
    <h4>Background: How NEBA integrates Spring into Sling</h4>
    <p>
        The <a href="https://osgi.org/specification/osgi.cmpn/7.0.0/service.blueprint.html">OSGi Blueprint specification</a> defines a declarative way
        to provide and consume OSGi services and beans using XML. The NEBA Spring module is using the reference implementation of this specification,
        <a href="https://www.eclipse.org/gemini/blueprint/">Gemini Blueprint</a>. Gemini Blueprint relies on the Spring Framework to create a fully-featured Application context
        based on the blueprint XML declaration. Resulting, the blueprint XML is a standard Spring XML application context with additional
        blueprint-specific capabilities, e.g. for declaring and consuming OSGI services.
    </p>
    <p>
        The NEBA spring module augments the capabilities of Gemini Blueprint with the ability to to use regular Spring Beans as Models for Resources by annotating them with
        <a href="apidocs/neba-api/io/neba/api/annotations/ResourceModel.html">@ResourceModel</a>.
    </p>
    <p>
        Furthermore, The NEBA Spring module enables using Spring MVC in Sling by Providing an OSGi-capable
        <a href="https://docs.spring.io/spring/docs/{{site.springDocumentationVersion}}/javadoc-api/org/springframework/web/servlet/DispatcherServlet.html">Dispatcher Servlet</a>. To avoid conflict with resource resolution and servlet mappings, <a
            href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/web.html#mvc">Spring MVC</a>
        is integrated into Sling using a Servlet with the fixed URL &quot;/bin/mvc&quot; (Resource Resolver
        mappings can be used to change this path). Since each distinct path in sling maps to a different resource (servlets are
        resources, too), the path /bin/mvc/url would not point to the /bin/mvc/ servlet. Thus, to have a request handled by
        the MVC servlet, the pseudo-extension&quot;.do&quot; is used. A spring controller for the path /my/controller/path
        is thus always addressed using /bin/mvc.do/my/controller/path.
    </p>
</section>

<section>
    <header>
        <h3 id="spring_setup">Setting up Spring with NEBA</h3>
    </header>
    <p>
        First, the NEBA Spring Module and the Spring OSGI bundles must be deployed to the OSGi container along with the NEBA API and core bundles.
        The <a href="/download.html#spring-integration">Downloads contain convenience packages</a> providing all of these bundles for installation in Adobe AEM&trade; and Apache Sling.
    </p>
    <p>
        Then, create a Spring application context XML file in the OSGI-INF/blueprint folder of your bundle. See the
        <a href="https://github.com/unic/neba-sample-project/tree/master/src/main/resources/OSGI-INF/blueprint">NEBA sample project</a> or use the following snippet:
    </p>
    <figure class="listing" id="listing:spring-setup">
{% highlight xml %}<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/mvc
                           http://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!-- Automatically discover spring beans below this package namespace.
        It is best-practice that this namespace is exclusive for the bundle to avoid conflicts with imported packages. -->
    <context:component-scan base-package="my.bundle.namespace"/>

    <!-- Setup the annotation-driven MVC infrastructure  -->
    <mvc:annotation-driven/>
</beans>{% endhighlight %}
        <figcaption>A sample Blueprint XML context</figcaption>
    </figure>

    <p>
        That's it - the bundle is now Blueprint enabled. When starting the bundle, The gemini-blueprint-extender bundle will <a href="https://www.eclipse.org/gemini/blueprint/documentation/reference/3.0.0.M01/html-single/index.html#bnd-app-ctx">automatically detect the declared
        XML contexts and create the Spring application context on behalf of the bundle</a>.
    </p>
</section>

<section>
    <header><h3 id="spring_beans_as_resource_models">Using Spring Beans as Resource Models</h3></header>

    <p>
        Spring beans (beans <a href="https://docs.spring.io/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/core.html#beans-stereotype-annotations">annotated with a spring stereotype such as @Component</a>) with a <a href="apidocs/neba-api/io/neba/api/annotations/ResourceModel.html">@ResourceModel</a> annotation are automatically
        registered as resource models by the NEBA Spring module when the application context starts. Such models <em>must</em> not be singletons,
        but rather have prototype scope as they are instantiated concurrently and represent a user-specific view on a Sling resource resolved
        during a HTTP request.
    </p>

<figure class="listing" id="listing:spring-bean-resource-model">
{% highlight java %}package my.bundle.namespace;

import org.springframework.stereotype.Component;
import io.neba.api-annotations.ResourceModel;
import org.springframework.context.annotation.Scope;

@Scope("prototype")
@Component
@ResourceModel("my/resource/type")
public class MyModel {
    ...
}{% endhighlight %}
<figcaption>Using the @ResourceModel annotation on a Spring Bean</figcaption>
</figure>
</section>

<p>
    When a resource is adapted to the respective model (or a super class or interface of the model), a model instance is obtained from the
    respective application context's bean factory. Subsequently, the resource data is mapped to the model via field injection and the resulting model
    is returned as the .adaptTo call result.
</p>
</section>
<section>
    <header>
        <h3 id="spring_mvc">Using Spring MVC in Sling</h3>
    </header>

<p>
    While NEBA provides a default MVC infrastructure similar to the defaults provided by Spring's DispatcherServlet,
    it is recommended to explicitly configure MVC support in the blueprint context using <code>&lt;mvc:annotation-driven /&gt;</code>. This also enables advanced features,
    such as automated conversion of controller responses to JSON.
</p>

<figure class="listing" id="listing:mvc-schema">{% highlight xml %}<?xml version="1.0" encoding="UTF-8"?>
<beans
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       ...
       xsi:schemaLocation="
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        ...">

    <mvc:annotation-driven />
</beans>{% endhighlight %}<figcaption>MVC schema snippet for blueprint XML declaration</figcaption></figure>

<p>Let's create a simple Controller called &quot;DemoController&quot;.
    We will use Spring's @Controller annotation; other styles (such as mapping by bean names etc.) are also
    supported. The purpose of this controller is to echo a parameter that we provide in a way that could be cached by AEM's Dispatcher cache.</p>

<figure class="listing" id="listing:controller-annotation">{% highlight java %}@Controller
public class DemoController {
}
{% endhighlight %}<figcaption>@Controller annotation usage</figcaption></figure>

<p>A @Controller is automatically detected and registered (as a singleton) by Spring's classpath scanning.
    Let's use Spring's REST support to both define the URL the controller listens to and the parameter we expect:</p>

<figure class="listing" id="listing:controller-annotation-requestmapping">{% highlight java %}@Controller
public class DemoController {
    @RequestMapping("/echo/{param}")
    @ResponseBody
    public String echo(@PathVariable("param") String paramToEcho) {
       return paramToEcho;
    }
}
{% endhighlight %}<figcaption>An echo @Controller example</figcaption></figure>

<p>That's it. You may now call your controller e.g. with /bin/mvc.do/echo/HelloWorld.txt.</p>

<p>Furthermore, NEBA automatically provides <a href="http://docs.spring.io/spring/docs/{{site.springDocumentationVersion}}/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html">handler method argument resolvers</a>
    for Sling-specific request elements, SlingHttpServletRequest and -Response, RequestPathInfo and ResourceResolver, like so:</p>

<figure class="listing" id="listing:controller-neba-argument-resolvers">{% highlight java %}@Controller
public class DemoController {
    @RequestMapping("/echoTitle")
    @ResponseBody
    public String echo(ResourceResolver resolver, RequestPathInfo info) {
       ...
    }

    @RequestMapping("/echoTitle")
    @ResponseBody
    public String echo(SlingHttpServletRequest request) {
        ...
    }
}
{% endhighlight %}<figcaption>NEBA argument resolvers for controller methods</figcaption></figure>

<p>It is thus not necessary to obtain these elements from the request.</p>

<p>Note that the annotation-driven controllers have a lot more very powerful options. See the
    <a href="http://docs.spring.io/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/web.html#mvc">Spring MVC
    documentation</a> for more examples. NEBA also supports Spring&apos;s special view names for redirecting and
    forwarding views: returning &quot;redirect:/some/path&quot; from a controller method will cause a redirect to
    /some/path, returning forward:/some/path will forward the request to /some/path, see also
    <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/web.html#mvc-redirecting-redirect-prefix">MVC redirecting</a>.</p>
    <p>You may also directly work with the response. For this, provide your own
View in the ModelAndView provided by the controller;
this way, your View's render method is used to render the response. Alternatively, you may also simply write to the
response and either let the controller method return &quot;null&quot; or make it void. This is however bad practice
and thus discouraged.</p>

<section>
<header><h3 id="mvc_sling_views">Using Sling Scripts as controller views</h3></header>
<p>
    NEBA supports using sling scripts to render controller views.
    NEBA provides a <a href="http://static.springsource.org/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/web.html#mvc-config-view-resolvers">view resolver</a>
    that resolves resource type names to the corresponding sling scripts and uses these to render views. Consider the following controller method:
</p>

<figure class="listing" id="listing:controller-sling-view-support">{% highlight java %}@Controller
public class DemoController {
    @RequestMapping("/myMethod")
    public String echo(@ResourceParam Page page) {
       // do something
       return "myApp/controllerViews/myView"
    }
}
{% endhighlight %}<figcaption>Calling Sling Views from Spring @Controllers</figcaption></figure>
<p>
    Here, NEBA's view resolver will resolve "myApp/controllerViews/myView" to the corresponding resource, e.g. "/apps/myApp/controllerViews/myView". It will then
    look for a suitable default script for the type, e.g. "myView.html" for a HTL (Sightly) template or "myView.jsp" for a JSP view. If no such script is found,
    the view resolver will re-attempt to resolve the default view for the <em>super type</em> of the view resource. This enables inheritance and
    overriding - just like for regular Sling resource views.
</p>
<p>
   Note that, contrary to the standard view resolution for Sling resources, controller view resolution does not take into account request methods,
   selectors or extensions. These aspects are used to address the Spring Controller and cannot be leveraged for view resolution without
   conflicting the Spring controller mapping.
</p>
<p>
    Each request to a Spring @Controller is associated with a generic <a href="https://docs.spring.io/spring/docs/{{site.springDocumentationVersion}}/spring-framework-reference/web.html#mvc-ann-modelattrib-methods">Model</a>.
    The attributes of this model are available as request attributes to Sling Scripts used as controller views. In a JSP view, for instance, a model attribute "page" can be accessed via:
</p>
<figure class="listing" id="listing:controller-view-variables">
{% highlight html %}${page}{% endhighlight %}
    <figcaption>Accessing Spring model attributes in JSP</figcaption></figure>

<p>
    In HTL (Sightly) however, request attributes could only be accessed indirectly up to HTL Engine 1.0.20,
    e.g. via <a href="https://sling.apache.org/documentation/bundles/scripting/scripting-htl.html#the-use-api">the HTL use API</a> (see for instance
    <a href="https://issues.apache.org/jira/browse/SLING-5812">SLING-5812</a>). Consequently, HTL (Sightly) users had to write additional code
    to obtain the Spring Controller invocation model data. Since NEBA 4.2.0, the Spring Controller Model is provided by the <a href="https://sling.apache.org/apidocs/sling8/org/apache/sling/api/resource/ValueMap.html">ValueMap</a>
    representation (aka properties) of the <a href="https://sling.apache.org/apidocs/sling8/org/apache/sling/api/resource/Resource.html">Resource</a> provided to the view script.
    Thus, a model attribute "page" could be accessed in HTL (Sightly) - and thus also in JSP - like so:
</p>
<figure class="listing" id="listing:accessing-model-attributes">
    {% highlight html %}${properties.page}{% endhighlight %}
    <figcaption>Accessing Spring model attributes in HTL (Sightly)</figcaption>
</figure>
</section>
<section>
<header><h3 id="mvc_resourceparam_annotation">Resolving resource path parameters with the @ResourceParam annotation</h3></header>

<p>NEBA supports the common use case of handling resource paths in controllers with a convenience annotation:</p>

<figure class="listing" id="listing:controller-resourceparam-annotation">{% highlight java %}@Controller
public class DemoController {
    @RequestMapping("/echoTitle")
    @ResponseBody
    public String echo(@ResourceParam Page page) {
       return page.getTitle();
    }
}
{% endhighlight %}<figcaption>Using the resource param annotations in Spring @Controllers</figcaption></figure>

<p>Here, a request parameter &quot;page&quot; is expected to contain a path to a resource. This resource is
    resolved and adapted to the parameter type in case the parameter type is not &quot;Resource&quot;.
    A <a href="apidocs/neba-spring/io/neba/spring/api/ResourceParam.html">@ResourceParam</a> can be optional or required.
    In addition, it can have a default value (a default resource path) that will be used in case the parameter is not present or empty:
</p>

<figure class="listing" id="listing:controller-resourceparam-defaultvalue">{% highlight java %}@Controller
public class DemoController {
    @RequestMapping("/echoTitle")
    @ResponseBody
    public String echo(@ResourceParam(defaultValue = "/default/resource/path") Page page) {
       return page.getTitle();
    }
}
{% endhighlight %}<figcaption>Using a default value for the @ResourceParam annotation</figcaption></figure>

<p>Here, "page" is implicitly considered optional since there is a default value.</p>

<p>
    Furthermore, the paths resolved by the <a href="apidocs/neba-spring/io/neba/spring/api/ResourceParam.html">@ResourceParam</a> annotations can be altered by appending an arbitrary sub-path:
</p>

<figure class="listing" id="listing:controller-resourceparam-append">{% highlight java %}@Controller
public class DemoController {
    @RequestMapping("/echoTitle")
    @ResponseBody
    public String echo(@ResourceParam(append = "/jcr:content") PageContent pageContent) {
       return pageContent.getTitle();
    }
}
{% endhighlight %}<figcaption>Altering the path resolved by the @ResourceParam annotation</figcaption></figure>

<p>
    The path specified in "append" is appended to the provided path or the specified default path prior to resolution.
</p>
</section>

<section><header><h3 id="request_scoped_beans">Support for request-scoped beans</h3></header>
<p>Beans in Spring have scopes. By default, beans are application scoped
    (i.e. singletons). For all Blueprint contexts created when the NEBA Spring module is present, NEBA enables support for the request scope, i.e. a bean may be defined like so:</p>

<figure class="listing" id="listing:request-scoped-beans">{% highlight java %}@Component
@Scope(WebApplicationContext.SCOPE_REQUEST)
public class MyType {
  ...
}{% endhighlight %}<figcaption>Using Spring's @Scope annotation on NEBA models</figcaption></figure>

<p>Note that while the request scope is enabled, the session scope is not. Using session-scoped beans will lead to a lot of issues such as lack of scalability
    due to the need of session stickiness to an instance, high memory usage and serialisation issues as bundles may be refreshed, which gives classes
    a new identity. The bottom line is: Using the session is discouraged in Apache Sling.</p>
</section>

</section>

<section>
    <header><h2 id="tooling">NEBA tooling for developers and administrators</h2></header>
    <p>
        To support developers beyond writing resource models, NEBA ships with a set of useful development and administration tools for exploring resource model
        characteristics as well as quickly resolving the resource model / content relationships. Finally, a log viewer integrated into the
        Felix console greatly improves issue analysis in cases where serial access to the system is an issue.
    </p>

    <h3 id="tooling_modelregistry">NEBA model registry</h3>
    <p>
        The <em>model registry</em> allows viewing all currently registered resource models, their source bundle and the resource types they are mapping to. In addition, the models
        can be filtered to find models mapping to specific content or models compatible to specific classes.
    </p>
    <p><img src="assets/images/modelregistry-large.png" alt="The NEBA model registry lists all resource models, their java type, bean name and source bundle id." class="full"/></p>


    <h3 id="tooling_modelstatistics">NEBA model statistics</h3>
    <p>
        For every detected resource model, NEBA extracts metadata that is reused to efficiently map resources to these models. Whenever resources are mapped to models,
        NEBA gathers data regarding the mapping duration. This combined resource model data is available via a JSON REST API in the model statistics console (/system/console/modelstatistics<wbr />/api/statistics).
    </p>
    <p>
        The NEBA model statistics console (/system/console/modelstatistics) uses this data to visualize the corresponding model characteristics. In addition, the console
        allows querying the data to display models with certain features, for instance to discover models performing below average and/or excessively
        loading data from the repository.
    </p>

    <p><img src="assets/images/modelstatistics-large.png" alt="The NEBA model statistics allows analyzing runtime performance characteristics of your model in real time." class="full"/></p>

    <p>
        This unique feature makes visible what could usually only be discovered through time-consuming analysis using a profiling tool.
        Furthermore, the model statistics allow real-time performance monitoring and analysis on <em>any system</em>.
        This is especially valuable for productive systems - there, content changes may trigger performance degradation and attaching a profiler
        usually isn't an option. NEBA's model statistics console makes finding performance bottleneck's in resource models fast and easy - further
        adding to better performing implementations.
    </p>

    <h3 id="tooling_logviewer">The  log viewer</h3>
    <p>
        Developers do not always have serial access to a system in order to analyse log files - however, being able to investigate the log files of a Sling instance
        is often key to finding and resolving issues timely. Here, NEBA provides the log viewer Felix console plugin - a safe way to view analyse and obtain the configured
        log files of a Sling instance for authenticated users of the Felix console.
    </p>
    <p>
        The log viewer automatically detects errors in the current log file excerpt of an error.log and allows tailing logfiles in real-time. It also allows downloading
        logfiles as ZIP compressed packages for offline analysis.
    </p>

    <p><img src="assets/images/logviewer-large.png" alt="The NEBA log viewer allows downloading and following all default and configured log files." class="full"/></p>
</section>

<section>
    <header>
        <h2 id="extending_neba">Extending NEBA</h2>
    </header>
<p>
    NEBA is extensible via a set of service interfaces provided in the <a href="apidocs/neba-api/io/neba/api/spi/package-summary.html">Service Provider Interface (SPI) API package</a>.
</p>
<h3 id="custom_annotations">Implementing custom annotations</h3>

<p>
    With NEBA, you can easily add your own annotations to provide additional features. Fields annotated with a custom annotation are handled by the corresponding
    OSGi service implementing the <a href="apidocs/neba-api/io/neba/api/spi/AnnotatedFieldMapper.html">AnnotatedFieldMapper interface</a>.
    Implementations may map any non-transient annotated field, including fields directly or indirectly (meta-annotations) annotated with any of NEBA's standard annotations.
    Thus, AnnotatedFieldMappers can not only be used to support custom annotations, but are allowed to augment NEBA's standard annotation-based mapping behavior.
</p>
    <p>
        Here is an example for an annotation and a custom processor that translates a field's string value using a locale obtained from the resource path.
    </p>
<figure class="listing" id="listing:custom-annotation">{% highlight java %}@Retention(RUNTIME)
public @interface Translate {
}


@Component(service = AnnotatedFieldMapper.class)
public class TranslateAnnotationMapper implements AnnotatedFieldMapper<String, Translate> {
    // E.g. /content/site/en_US/...
    private static final Pattern LANGUAGE_IN_PATH = compile("/content/(?<site>[^/]+)/(?<locale>[A-z]{2}(_[A-z]{2})?)/.*");

    @Reference
    @Filter("(component.name=org.apache.sling.i18n.impl.JcrResourceBundleProvider)")
    private ResourceBundleProvider resourceBundleProvider;

    @Nonnull
    @Override
    public Class<? super String> getFieldType() {
        return String.class;
    }

    @Nonnull
    @Override
    public Class<Translate> getAnnotationType() {
        return Translate.class;
    }

    @CheckForNull
    @Override
    public String map(OngoingMapping<String, Translate> ongoingMapping) {
        String value = ongoingMapping.getResolvedValue();
        if (isEmpty(value)) {
            return value;
        }
        return resourceBundleProvider.getResourceBundle(getLocale(ongoingMapping.getResource())).getString(value);
    }

    private Locale getLocale(Resource resource) {
        return LocaleUtils.toLocale(LANGUAGE_IN_PATH.matcher(resource.getPath()).group("locale"));
    }
}
    {% endhighlight %}<figcaption>Providing a mapper for custom annotations</figcaption></figure>

    <p>This annotation could then be used in your model like so:</p>

    <figure class="listing" id="listing:explicit-lazy-loading-collections">
        {% highlight java %}@ResourceModel("project/components/cta")
public class CallToAction {
  @Translate
  private String buttonText;
}{% endhighlight %}<figcaption>Using a custom annotation on a model's field</figcaption></figure>

<h3 id="lifecycle_callbacks">Lifecycle callbacks</h3>

<p>After creation and dependency injection, a resource model is injected with the properties of the resource which is adapted to the model.
    For programmatic extensibility, the NEBA API contains the lifecycle callback interface <a href="apidocs/neba-api/io/neba/api/spi/ResourceModelPostProcessor.html">ResourceModelPostProcessor</a>.
    Providing an OSGi service with this interface allows customizing and even overriding a ResourceModel after the resource properties are mapped to it.
</p>

<h3 id="custom_models">Providing custom resource model factories</h3>

<p>
    NEBA automatically registers models provided by <a href="apidocs/neba-api/io/neba/api/spi/ResourceModelFactory.html">ResourceModelFactory OSGi services</a>.
    Thus, resource model factories can be provided by publishing a ResourceModelFactory OSGI service. NEBA core, for instance, publishes such a
    factory for resource models declared using the <a href="#add_neba_packages_header">Neba-Packages</a> header.
</p>

<h3 id="custom_aop_support">Custom AOP support</h3>

<p>
    AOP sometimes involves wrapping java objects in proxies or otherwise enhancing their type. If resource models are enhanced in this fashion before NEBA
    maps resource data or injects collaborators, NEBA may no longer be able to do so since the required fields or bean properties are no longer accessible.
    Here, one can publish an <a href="apidocs/neba-api/io/neba/api/spi/AopSupport.html">AopSupport</a> service. This service is asked to prepare a (potentially
    AOP-enhanced) model instance for injection. For instance, this service may return the underlying target of an AOP proxy instance, or the
    original object if it is not enhanced. NEBA's spring integration module, for instance, publishes an <a href="/apidocs/neba-spring/io/neba/spring/resourcemodels/aop/AopSupportImpl.html">AopSupport service for CGlib proxies</a>.
</p>
</section>

<section>
    <header><h2>The Architecture of NEBA</h2></header>

    <p>The following documentation is not meant to be complete in a sense of covering every implementation detail. It strives to illustrate
        the core design ideas, as well as the most important components and processes of NEBA.
    </p>


    <h3 id="architecture_bundles">Bundles</h3>

    <p>NEBA's main functionality is delivered by two bundles, API and core. The API exclusively contains annotations, interfaces and tag libraries and has no dependency
    to the core bundle. It is designed to rarely change and to be the exclusive interface between code using NEBA and the NEBA implementation, thus completely
    separating application code from NEBA's implementation concerns.</p>

    <img src="assets/images/neba-core.png" alt="NEBA is composed of a core and api bundle. The core bundle uses the Sling and the JCR API.">

    <p>
        In addition, NEBA provides a Spring integration bundle. This bundle enables using Spring Beans as Models for Resources and Spring MVC within Apache Sling.
        The Spring integration is exclusively based on <a href="https://www.eclipse.org/gemini/blueprint/">Gemini Blueprint</a>, the Open Source Reference Implementation of the OSGi Blueprint specification.
    </p>

    <img src="assets/images/neba-spring.png" alt="NEBA provides an addition Spring integration bundle, which enables using Spring Beans as models for resources as well as Spring MVC in Sling.">

    <h3 id="architecture_resource_model_registration">Resource model detection</h3>

    <p>Similar to Sling models, the NEBA core registers classes annotated with <a href="#working_with_resourcemodels">@ResourceModel</a> in the packages contained in the <a href="#add_neba_packages_header">Neba-Packages header</a> of a bundle. Subsequently, the bundle containing the models
    is augmented with a <a href="apidocs/neba-api/io/neba/api/spi/ResourceModelFactory.html">Resource Model Factory Service</a> representing the models. This service implementation is also responsible for providing instances of the models and performing basic instantiation services, such as dependency injection and invoking life cycle callbacks.</p>

    <img src="assets/images/neba-core-model-registration.png" alt="Upon bundle activation, the NEBA core scans the classes in the packages defined in the Neba-Packages header of a bundle and exposes the resulting resource models via a ResourceModelFactory service." >

    <p>
        The NEBA Spring support post-processes the Blueprint application context of a bundle, looking for Spring Beans annotated with <a href="#working_with_resourcemodels">@ResourceModel</a>.
        In addition, the Spring support enables request-scoped Spring beans and Spring MVC in Sling.
    </p>

    <img src="assets/images/neba-spring-model-registration.png" alt="NEBA Spring post-processes blueprint application contexts before they are refreshed, finding beans annotated with @ResourceModel. The resulting resource models are exposed via a ResourceModelFactory service." >

    <h3 id="architecture_modelregistration">Resource model registration and adaptation</h3>

    <p>The registration of resource models and the subsequent management of the resource model metadata for mapping purposes
        account for the most valuable NEBA features. Here, the NEBA core collects all <a href="apidocs/neba-api/io/neba/api/spi/ResourceModelFactory.html">ResourceModelFactory</a> services and registers all models provided by them.
        Subsequently, NEBA core publishes a Sling <a href="https://sling.apache.org/documentation/the-sling-engine/adapters.html#adapterfactory">Adapter Factory</a> allowing the adaptation
        from resources with the suitable type(s) to the respective models. The mapping of resources and their properties to the resource models is done by NEBA core during such an adaptation.
    </p>

    <img src="assets/images/neba-resourcemodel-registration-and-adaptation.png" alt="NEBA core registers all ResourceModelFactory services, and provides a Sling AdapterFactory for the respective models.">
</section>

<section>
    <header><h2 id="upgrading">Upgrading from previous versions</h2></header>

    <p>
        Please use the below form to see the upgrade path from one version of NEBA to another.
    </p>

    {% assign posts = site.posts | where_exp:"item", "item.tags contains 'release'" | sort: "release.version" %}
    <form title="Upgrading from..." id="upgradePathForm">
        <fieldset title="Version selection">
            See changes required when upgrading
            <label for="fromVersion">from</label>
            <select id="fromVersion">
                <option value="">Please choose</option>
                {% for post in posts %}
                <option name="{{ post.release.version }}">{{ post.release.version }}</option>
                {% endfor %}

            </select>
            <label for="toVersion">to</label>
            <select id="toVersion">
                <option value="">Please choose</option>
                {% for post in posts %}
                <option name="{{ post.release.version }}">{{ post.release.version }}</option>
                {% endfor %}
            </select>
            <button type="submit">Submit</button>
        </fieldset>
    </form>

    <section id="requiredChanges"></section>
    <script async src="/js/upgradepath.js"></script>
</section>
</main>

{% include footer.ext %}
</body>
</html>
